<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stellar Radio Hub</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ðŸŽ§</text></svg>">
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
<style>
        :root {
            --primary-color: #4a4de7;
            --secondary-color: #e91e63;
            --background-color: #f4f6f8;
            --text-color: #333333;
            --card-background: #ffffff;
            --hover-color: #e8eaf6;
            --bg-image: url('https://images.unsplash.com/photo-1507838153414-b4b713384a76?ixlib=rb-1.2.1&auto=format&fit=crop&w=1950&q=80');
            --container-bg: rgba(255, 255, 255, 0.95);
            --container-border: 1px solid rgba(255, 255, 255, 0.2);
        }

        /* Dark theme */
        [data-theme="dark"] {
            --primary-color: #6c63ff;
            --secondary-color: #ff9cbc; /* Even softer pink */
            --background-color: #121212;
            --text-color: #e0e0e0;
            --card-background: #1e1e1e;
            --hover-color: #2c2c2c;
            --bg-image: url('https://images.unsplash.com/photo-1514320291840-2e0a9bf2a9ae?ixlib=rb-1.2.1&auto=format&fit=crop&w=1950&q=80');
            --container-bg: rgba(30, 30, 30, 0.95);
            --container-border: 1px solid rgba(255, 255, 255, 0.1);
            --search-bg: #2c2c2c;
            --search-text: #ffffff;
            --station-card-border: 1px solid #444;
            --recently-played-text: #d0d0d0;
        }

        [data-theme="dark"] body {
            background-image: linear-gradient(rgba(0, 0, 0, 0.9), rgba(0, 0, 0, 0.9)), 
                          var(--bg-image);
        }

        [data-theme="dark"] #search-input {
            border: 1px solid #555;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        [data-theme="dark"] .category-filter button {
            border: 1px solid #555;
            background-color: #252525;
        }

        [data-theme="dark"] #station-list li, 
        [data-theme="dark"] #favorites-list li {
            border: var(--station-card-border);
            background: #252525;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        [data-theme="dark"] .recently-played {
            color: var(--recently-played-text);
        }

        [data-theme="dark"] #favorites-empty-state {
            color: #d0d0d0;
            font-weight: 500;
        }

        /* Accessibility improvements */
        [data-theme="dark"] h1, 
        [data-theme="dark"] h2,
        [data-theme="dark"] .station-name,
        [data-theme="dark"] #now-playing,
        [data-theme="dark"] #track-info,
        [data-theme="dark"] #search-input::placeholder,
        [data-theme="dark"] .category-filter button,
        [data-theme="dark"] .recently-played li {
            color: #ffffff;
        }

        [data-theme="dark"] #toggle-favorite {
            background-color: var(--secondary-color);
            color: #121212;
        }

        [data-theme="dark"] #toggle-favorite:hover {
            background-color: #ff79b0;
        }

        /* Empty state styling */
        [data-theme="dark"] #favorites-empty-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 2rem 0;
            color: #b0b0b0;
        }

        [data-theme="dark"] #favorites-empty-state i {
            font-size: 3rem;
            margin-bottom: 1rem;
            color: var(--secondary-color);
        }

        [data-theme="dark"] #favorites-empty-state p {
            font-size: 1.1rem;
            text-align: center;
        }

        /* Light theme */
        [data-theme="light"] {
            --primary-color: #3f51b5;
            --secondary-color: #f50057;
            --background-color: #ffffff;
            --text-color: #212121;
            --card-background: #f5f5f5;
            --hover-color: #e0e0e0;
            --bg-image: url('https://images.unsplash.com/photo-1511671782779-c97d3d27a1d4?ixlib=rb-1.2.1&auto=format&fit=crop&w=1950&q=80');
            --container-bg: rgba(245, 245, 245, 0.95);
            --container-border: 1px solid rgba(0, 0, 0, 0.1);
        }

        /* Nature Green theme */
        [data-theme="nature"] {
            --primary-color: #2e7d32;
            --secondary-color: #ff6d00;
            --background-color: #e8f5e9;
            --text-color: #1b5e20;
            --card-background: #c8e6c9;
            --hover-color: #a5d6a7;
            --bg-image: url('https://images.unsplash.com/photo-1465847899084-d164df4dedc6?ixlib=rb-1.2.1&auto=format&fit=crop&w=1950&q=80');
            --container-bg: rgba(200, 230, 201, 0.95);
            --container-border: 1px solid rgba(46, 125, 50, 0.2);
            --search-bg: #81c784;
            --search-text: #1b5e20;
            --play-button-bg: #ff6d00;
            --play-button-text: #ffffff;
        }

        body {
            font-family: 'Poppins', sans-serif;
            margin: 0;
            padding: 0;
            color: var(--text-color);
            line-height: 1.6;
            background-image: linear-gradient(rgba(255, 255, 255, 0.5), rgba(255, 255, 255, 0.5)), 
                          var(--bg-image);
            background-size: cover;
            background-position: center;
            background-attachment: fixed;
            animation: backgroundMove 60s linear infinite;
            overflow-x: hidden; /* Prevent horizontal scrolling */
        }
        @keyframes backgroundMove {
            0% {
                background-position: 0% 50%;
            }
            50% {
                background-position: 100% 50%;
            }
            100% {
                background-position: 0% 50%;
            }
        }
        .app-container {
            max-width: 1000px;
            margin: 2rem auto;
            padding: 1.5rem;
            background-color: var(--container-bg);
            backdrop-filter: blur(15px);
            border-radius: 16px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            border: var(--container-border);
            width: 95%;
            max-width: 1000px;
            box-sizing: border-box;
        }
        .container {
            background: var(--card-background);
            border-radius: 12px;
            padding: 1.2rem;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.05);
            margin-bottom: 1.2rem;
            border: 1px solid rgba(var(--primary-color), 0.1);
        }
        h1, h2 {
            text-align: center;
            color: var(--primary-color);
        }
        h1 {
            font-size: 2.2rem;
            margin-bottom: 0.8rem;
        }
        h2 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
        }
        #station-list, #favorites-list {
            list-style-type: none;
            padding: 0;
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 1.5rem;
        }
        #station-list li, #favorites-list li {
            cursor: pointer;
            padding: 1rem;
            background: var(--card-background);
            border-radius: 8px;
            transition: all 0.3s ease, transform 0.1s ease;
            display: flex;
            align-items: center;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            border: 1px solid rgba(74, 77, 231, 0.05);
        }
        #station-list li:hover, #favorites-list li:hover {
            transform: translateY(-2px) scale(1.02);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.12);
            background-color: var(--hover-color);
        }
        #controls {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 1rem;
            flex-wrap: wrap;
            margin-top: 1.5rem;
        }
        button {
            padding: 0.8rem 1.2rem;
            font-size: 1rem;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }
        #play-pause {
            background-color: var(--play-button-bg, #3949ab);
            color: var(--play-button-text, white);
        }
        #play-pause:hover {
            background-color: var(--secondary-color);
        }
        #toggle-favorite {
            background-color: var(--secondary-color);
            color: white;
        }
        #toggle-favorite:hover {
            background-color: #d81b60;
        }
        #volume {
            width: 150px;
            -webkit-appearance: none;
            background: #e0e0e0;
            outline: none;
            border-radius: 15px;
            overflow: hidden;
        }
        #volume::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--primary-color);
            cursor: pointer;
            border: 2px solid #fff;
            box-shadow: -407px 0 0 400px var(--primary-color);
        }
        #now-playing, #track-info {
            margin-top: 1rem;
            font-weight: 600;
            text-align: center;
            color: var(--text-color);
        }
        .unavailable {
            opacity: 0.5;
            text-decoration: line-through;
            cursor: not-allowed;
        }
        .playing {
            background-color: var(--primary-color) !important;
            color: white;
            font-weight: bold;
        }
        #search-container {
            display: flex;
            justify-content: center;
            margin-bottom: 2rem;
            width: 100%;
            padding: 0 1rem;
            box-sizing: border-box;
        }

        .search-wrapper {
            position: relative;
            width: 100%;
            max-width: 400px;
        }

        #search-input {
            width: 100%;
            padding: 0.7rem 1rem 0.7rem 2.5rem;
            border: 1px solid var(--primary-color);
            border-radius: 25px;
            font-size: 1rem;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
            transition: all 0.3s ease;
            box-sizing: border-box;
            background-color: var(--search-bg, var(--card-background));
            color: var(--search-text, var(--text-color));
        }

        #search-input:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 2px 10px rgba(74, 77, 231, 0.2);
        }

        #search-icon {
            position: absolute;
            left: 1rem;
            top: 50%;
            transform: translateY(-50%);
            color: var(--search-text, #666);
            pointer-events: none;
        }

        #equalizer {
            display: flex;
            justify-content: center;
            align-items: flex-end;
            height: 50px;
            margin-top: 1rem;
        }
        .bar {
            width: 8px;
            background-color: var(--primary-color);
            margin: 0 2px;
            transition: height 0.2s ease;
            border-radius: 4px 4px 0 0;
        }
        footer {
            background-color: var(--card-background);
            color: var(--text-color);
            text-align: center;
            padding: 1rem 0;
            border-top: 1px solid rgba(74, 77, 231, 0.1);
            position: static;
            width: 100%;
            bottom: 0;
            box-sizing: border-box;
            max-width: 100%;
        }
        .footer-content {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            justify-content: center;
            align-items: center;
            max-width: 1000px;
            margin: 0 auto;
            font-size: 0.8rem;
            padding: 0 0.5rem;
            box-sizing: border-box;
        }
        .social-icons {
            display: flex;
            gap: 1rem;
            justify-content: center;
        }
        .social-icons a {
            color: var(--text-color);
            font-size: 1.2rem;
            transition: color 0.3s ease;
        }
        .social-icons a:hover {
            color: var(--primary-color);
        }
        .station-icon {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 1rem;
            font-size: 1.4rem;
            color: white;
            flex-shrink: 0;
            position: relative;
        }
        .station-category {
            position: absolute;
            top: -5px;
            right: -5px;
            background-color: #4a4de7;
            color: white;
            font-size: 0.7rem;
            padding: 2px 5px;
            border-radius: 10px;
        }
        .station-name {
            font-weight: 600;
            font-size: 1.1rem;
        }
        .container + .container {
            margin-top: 2rem;
        }
        #favorites-empty-state {
            text-align: center;
            color: #666;
            font-style: italic;
            padding: 2rem 0;
        }

        .category-filter {
            display: flex;
            justify-content: center;
            gap: 0.5rem;
            margin-bottom: 1rem;
            flex-wrap: wrap;
        }

        .category-filter button {
            background-color: var(--card-background);
            color: var(--text-color);
            border: 1px solid var(--primary-color);
            padding: 0.5rem 1rem;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .category-filter button.active {
            background-color: var(--primary-color);
            color: white;
        }

        .recently-played {
            margin-top: 1rem;
            font-size: 0.9rem;
            color: #666;
        }

        .recently-played ul {
            list-style-type: none;
            padding: 0;
            margin: 0.5rem 0 0 0;
        }

        .recently-played li {
            cursor: pointer;
            padding: 0.3rem 0;
            transition: color 0.3s ease;
        }

        .recently-played li:hover {
            color: var(--primary-color);
        }

        .remove-favorite {
            position: absolute;
            top: 5px;
            right: 5px;
            color: var(--secondary-color);
            cursor: pointer;
            font-size: 1rem;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        #favorites-list li:hover .remove-favorite {
            opacity: 1;
        }

        @media (max-width: 768px) {
            .app-container {
                padding: 1rem;
            }

            #station-list, #favorites-list {
                grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
            }

            #search-container {
                padding: 0;
            }

            .search-wrapper {
                max-width: 100%;
            }

            #search-input {
                font-size: 0.9rem;
                padding: 0.6rem 1rem 0.6rem 2.2rem;
            }

            #search-icon {
                left: 0.8rem;
                font-size: 0.9rem;
            }
        }

        /* Add this new style for the theme switcher */
        #theme-switcher {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
        }

        #theme-switcher select {
            padding: 5px 10px;
            border-radius: 5px;
            border: 1px solid var(--primary-color);
            background-color: var(--card-background);
            color: var(--text-color);
        }
    </style>
</head>
<body>
    <div id="theme-switcher">
        <select id="theme-select">
            <option value="default">Default Theme</option>
            <option value="dark">Dark Theme</option>
            <option value="light">Light Theme</option>
            <option value="nature">Nature Green Theme</option>
        </select>
    </div>

    <div class="app-container">
        <div class="container">
            <h1><i class="fas fa-broadcast-tower"></i> Stellar Radio Hub</h1>
            <audio id="audio-player">
                <source src="" type="audio/mpeg">
                <source src="" type="audio/ogg">
                <source src="" type="application/ogg">
            </audio>
            <div id="controls">
                <button id="play-pause"><i class="fas fa-play"></i> Play</button>
                <input type="range" id="volume" min="0" max="1" step="0.1" value="1">
                <button id="toggle-favorite"><i class="far fa-heart"></i> Favorite</button>
            </div>
            <div id="now-playing"></div>
            <div id="track-info"></div>
            <div id="equalizer">
                <div class="bar"></div>
                <div class="bar"></div>
                <div class="bar"></div>
                <div class="bar"></div>
                <div class="bar"></div>
            </div>
        </div>

        <div class="container">
            <h2><i class="fas fa-list"></i> Available Stations</h2>
            <div id="search-container">
                <div class="search-wrapper">
                    <input type="text" id="search-input" placeholder="Search stations...">
                    <i class="fas fa-search" id="search-icon"></i>
                </div>
            </div>
            <div class="category-filter">
                <button class="active" data-category="all">All</button>
                <button data-category="Music">Music</button>
                <button data-category="News">News</button>
                <button data-category="Talk">Talk</button>
                <button data-category="Fitness">Fitness</button>
                <button data-category="Spiritual">Spiritual</button>
            </div>
            <ul id="station-list">
                <!-- Stations will be added here dynamically -->
            </ul>
        </div>

        <div class="container">
            <h2><i class="fas fa-star"></i> Favorite Stations</h2>
            <ul id="favorites-list"></ul>
            <div id="favorites-empty-state">You have no favorite stations yet. Start adding!</div>
        </div>

        <div class="container">
            <h2><i class="fas fa-history"></i> Recently Played</h2>
            <div class="recently-played">
                <ul id="recently-played-list"></ul>
            </div>
        </div>
    </div>

    <footer>
        <div class="footer-content">
            <p>&copy; 2024 Stellar Radio Hub. All rights reserved.</p>
            <div class="social-icons">
                <a href="https://x.com/iamsumitgaur" target="_blank"><i class="fab fa-twitter"></i></a>
                <a href="https://github.com/kumar-400" target="_blank"><i class="fab fa-github"></i></a>
                <a href="#" target="_blank"><i class="fab fa-facebook"></i></a>
                <a href="#" target="_blank"><i class="fab fa-instagram"></i></a>
            </div>
        </div>
    </footer>

    <!-- JavaScript section -->
<script>
// Enhanced Audio Player with multi-format stream support
class EnhancedAudioPlayer {
    constructor(options = {}) {
        this.audioElement = options.audioElement || document.createElement('audio');
        this.fallbackFormats = options.fallbackFormats || ['mp3', 'aac', 'ogg', 'opus', 'flac'];
        this.crossOrigin = options.crossOrigin || 'anonymous';
        this.maxRetries = options.maxRetries || 3;
        this.retryDelay = options.retryDelay || 2000;
        this.timeout = options.timeout || 15000; // Stream connection timeout in ms
        
        this.currentStation = null;
        this.currentFormat = null;
        this.retryCount = 0;
        this.stationQueue = [];
        this.isLoading = false;
        this.hls = null;

        this.events = {
            stationLoaded: [],
            stationChanged: [],
            error: [],
            play: [],
            pause: [],
            volumeChange: [],
            metadataUpdate: []
        };
        
        // Setup audio element
        this.audioElement.setAttribute('crossorigin', this.crossOrigin);
        this.audioElement.preload = 'auto';
        
        // Setup event listeners
        this.setupEventListeners();
        
        // Check for HLS.js support
        this.initHLSSupport();
        
        // Setup metadata tracking
        this.setupMetadataTracking();
    }

    // Initialize HLS.js if available
    initHLSSupport() {
        // Check if HLS.js is already loaded
        if (window.Hls && Hls.isSupported()) {
            this.hlsSupported = true;
            console.log('HLS.js is supported');
        } else {
            // Try to load HLS.js dynamically
            this.loadHLSScript()
                .then(() => {
                    if (window.Hls && Hls.isSupported()) {
                        this.hlsSupported = true;
                        console.log('HLS.js loaded dynamically and supported');
                    } else {
                        this.hlsSupported = false;
                        console.log('HLS.js is not supported or failed to load');
                    }
                })
                .catch(error => {
                    this.hlsSupported = false;
                    console.warn('Failed to load HLS.js:', error);
                });
        }
    }

    // Dynamically load HLS.js
    loadHLSScript() {
        return new Promise((resolve, reject) => {
            if (window.Hls) {
                return resolve();
            }

            const script = document.createElement('script');
            script.src = 'https://cdnjs.cloudflare.com/ajax/libs/hls.js/1.4.0/hls.min.js';
            script.integrity = 'sha512-+GD80rqUK1ZrQjXa3aEIf1HvNT6DCrOsKO9u6BArvI499s+5yrg1HZQqje2jdqF5L2YKGJ7w5swG5bEzd0qLIg==';
            script.crossOrigin = 'anonymous';
            script.onload = () => resolve();
            script.onerror = () => reject(new Error('Failed to load HLS.js'));
            document.head.appendChild(script);
        });
    }

    // Setup audio element event listeners
    setupEventListeners() {
        this.audioElement.addEventListener('playing', () => this.triggerEvent('play'));
        this.audioElement.addEventListener('pause', () => this.triggerEvent('pause'));
        this.audioElement.addEventListener('volumechange', () => {
            this.triggerEvent('volumeChange', this.audioElement.volume);
        });
        this.audioElement.addEventListener('error', (e) => {
            const error = e.target.error;
            if (error) {
                this.handlePlaybackError(error);
            }
        });
    }

    // Handle playback errors
    handlePlaybackError(error) {
        console.error('Audio playback error:', error);
        
        // Try next format if we have fallbacks
        if (this.currentStation && this.retryCount < this.maxRetries) {
            this.retryCount++;
            setTimeout(() => {
                this.tryNextFormat();
            }, this.retryDelay);
        } else {
            this.isLoading = false;
            this.triggerEvent('error', {
                type: 'playback',
                message: `Failed to play after ${this.maxRetries} attempts`,
                originalError: error
            });
        }
    }

    // Try playing the current station with the next format in the fallback list
    tryNextFormat() {
        if (!this.currentStation) return;
        
        const formatIndex = this.fallbackFormats.indexOf(this.currentFormat);
        const nextFormatIndex = (formatIndex + 1) % this.fallbackFormats.length;
        this.currentFormat = this.fallbackFormats[nextFormatIndex];
        
        console.log(`Trying next format: ${this.currentFormat}`);
        this.playStream(this.currentStation.url);
    }

    // Setup metadata tracking
    setupMetadataTracking() {
        if ('mediaSession' in navigator) {
            navigator.mediaSession.setActionHandler('play', () => this.play());
            navigator.mediaSession.setActionHandler('pause', () => this.pause());
        }
    }

    // Load a stream for a station
    async loadStation(station) {
        if (this.isLoading) return false;
        
        this.isLoading = true;
        this.currentStation = station;
        this.retryCount = 0;
        this.currentFormat = this.fallbackFormats[0];
        
        this.triggerEvent('stationChanged', station);
        
        try {
            await this.playStream(station.url);
            this.triggerEvent('stationLoaded', station);
            return true;
        } catch (error) {
            console.error('Failed to load station:', error);
            this.triggerEvent('error', { 
                type: 'station', 
                message: 'Failed to load station', 
                originalError: error 
            });
            this.isLoading = false;
            return false;
        }
    }

    // Play a specific audio stream URL
    async playStream(url) {
        // Clear any existing streams
        this.reset();
        
        try {
            // Check if this is an HLS stream
            if (url.includes('.m3u8') && this.hlsSupported) {
                await this.playHLSStream(url);
            } 
            // Check if this is an MPEG-DASH stream
            else if (url.includes('.mpd') && window.dashjs) {
                await this.playDashStream(url);
            }
            // Regular audio stream
            else {
                await this.playRegularStream(url);
            }
        } catch (error) {
            console.error('Error playing stream:', error);
            throw error;
        }
    }

    // Play an HLS stream using HLS.js
    async playHLSStream(url) {
        return new Promise((resolve, reject) => {
            const timeout = setTimeout(() => {
                reject(new Error('HLS stream loading timeout'));
            }, this.timeout);

            try {
                // Create a new HLS instance
                if (this.hls) {
                    this.hls.destroy();
                }
                
                this.hls = new Hls({ enableWorker: true });
                
                this.hls.on(Hls.Events.MEDIA_ATTACHED, () => {
                    console.log('HLS media attached');
                    this.hls.loadSource(url);
                });
                
                this.hls.on(Hls.Events.MANIFEST_PARSED, () => {
                    console.log('HLS manifest parsed');
                    clearTimeout(timeout);
                    this.audioElement.play()
                        .then(() => resolve())
                        .catch(error => reject(error));
                });
                
                this.hls.on(Hls.Events.ERROR, (event, data) => {
                    console.error('HLS error:', data);
                    if (data.fatal) {
                        clearTimeout(timeout);
                        reject(new Error(`HLS fatal error: ${data.type}`));
                    }
                });
                
                this.hls.attachMedia(this.audioElement);
            } catch (error) {
                clearTimeout(timeout);
                reject(error);
            }
        });
    }

    // Play an MPEG-DASH stream using dash.js
    async playDashStream(url) {
        return new Promise((resolve, reject) => {
            const timeout = setTimeout(() => {
                reject(new Error('DASH stream loading timeout'));
            }, this.timeout);

            // Load dash.js if not available
            if (!window.dashjs) {
                this.loadDashScript()
                    .then(() => this.initDashPlayer(url, timeout, resolve, reject))
                    .catch(error => {
                        clearTimeout(timeout);
                        reject(error);
                    });
            } else {
                this.initDashPlayer(url, timeout, resolve, reject);
            }
        });
    }

    // Initialize the DASH player
    initDashPlayer(url, timeout, resolve, reject) {
        try {
            if (this.dashPlayer) {
                this.dashPlayer.reset();
            } else {
                this.dashPlayer = dashjs.MediaPlayer().create();
            }
            
            this.dashPlayer.initialize(this.audioElement, url, true);
            
            this.dashPlayer.on('playbackMetaDataLoaded', () => {
                clearTimeout(timeout);
                this.audioElement.play()
                    .then(() => resolve())
                    .catch(error => reject(error));
            });
            
            this.dashPlayer.on('error', (error) => {
                clearTimeout(timeout);
                reject(error);
            });
        } catch (error) {
            clearTimeout(timeout);
            reject(error);
        }
    }

    // Load dash.js dynamically
    loadDashScript() {
        return new Promise((resolve, reject) => {
            const script = document.createElement('script');
            script.src = 'https://cdnjs.cloudflare.com/ajax/libs/dashjs/4.7.1/dash.all.min.js';
            script.integrity = 'sha512-3q3S2VQvCHLK1qJlabpRO0A5gZiMkBvqXdxR9z5yvZZ+pTELpwKLzSYPHJsVrVdX5epkKM2Hz6Em5IJ4Lw+OZA==';
            script.crossOrigin = 'anonymous';
            script.onload = () => resolve();
            script.onerror = () => reject(new Error('Failed to load dash.js'));
            document.head.appendChild(script);
        });
    }

    // Play a regular audio stream
    async playRegularStream(url) {
        return new Promise((resolve, reject) => {
            const timeout = setTimeout(() => {
                reject(new Error('Stream loading timeout'));
            }, this.timeout);
            
            const onCanPlay = () => {
                this.audioElement.removeEventListener('canplay', onCanPlay);
                this.audioElement.removeEventListener('error', onError);
                clearTimeout(timeout);
                this.audioElement.play()
                    .then(() => resolve())
                    .catch(error => reject(error));
            };
            
            const onError = (e) => {
                this.audioElement.removeEventListener('canplay', onCanPlay);
                this.audioElement.removeEventListener('error', onError);
                clearTimeout(timeout);
                reject(e.target.error || new Error('Failed to load audio'));
            };
            
            this.audioElement.addEventListener('canplay', onCanPlay);
            this.audioElement.addEventListener('error', onError);
            
            this.audioElement.src = url;
            this.audioElement.load();
        });
    }

    // Reset the player state
    reset() {
        if (this.hls) {
            this.hls.destroy();
            this.hls = null;
        }
        
        if (this.dashPlayer) {
            this.dashPlayer.reset();
        }
        
        this.audioElement.removeAttribute('src');
        this.audioElement.load();
    }

    // Play the current stream
    async play() {
        if (!this.audioElement.src && this.currentStation) {
            return this.loadStation(this.currentStation);
        }
        
        try {
            await this.audioElement.play();
            this.triggerEvent('play');
            return true;
        } catch (error) {
            console.error('Play error:', error);
            this.triggerEvent('error', { type: 'play', message: 'Failed to play', originalError: error });
            return false;
        }
    }

    // Pause the current stream
    pause() {
        this.audioElement.pause();
        this.triggerEvent('pause');
    }

    // Set the volume (0 to 1)
    setVolume(volume) {
        this.audioElement.volume = Math.max(0, Math.min(1, volume));
    }

    // Get current playback state
    getState() {
        return {
            currentStation: this.currentStation,
            isPlaying: !this.audioElement.paused,
            volume: this.audioElement.volume,
            muted: this.audioElement.muted,
            isLoading: this.isLoading
        };
    }

    // Add event listener
    on(eventName, callback) {
        if (this.events[eventName]) {
            this.events[eventName].push(callback);
        }
        return this;
    }

    // Remove event listener
    off(eventName, callback) {
        if (this.events[eventName]) {
            this.events[eventName] = this.events[eventName].filter(cb => cb !== callback);
        }
        return this;
    }

    // Trigger an event
    triggerEvent(eventName, data) {
        if (this.events[eventName]) {
            this.events[eventName].forEach(callback => callback(data));
        }
    }

    // Check if a stream URL is playable
    static isStreamSupported(url) {
        // Check for common stream URL extensions
        const supportedExtensions = [
            '.mp3', '.aac', '.ogg', '.opus', '.flac', '.wav',
            '.m3u', '.m3u8', '.pls', '.xspf', '.mpd'
        ];
        
        for (const ext of supportedExtensions) {
            if (url.toLowerCase().includes(ext)) return true;
        }
        
        // Check for common stream URL patterns
        const streamPatterns = [
            '/stream', '/live', '/audio', '/radio', '/mp3', '/aac',
            'icecast', 'shoutcast', 'streaming', 'radiostreamurl'
        ];
        
        for (const pattern of streamPatterns) {
            if (url.toLowerCase().includes(pattern)) return true;
        }
        
        return false;
    }

    // Parse different playlist formats
    static async parsePlaylist(url) {
        try {
            const response = await fetch(url);
            const content = await response.text();
            
            // Check the URL extension or content to determine the format
            if (url.endsWith('.m3u') || url.endsWith('.m3u8') || content.includes('#EXTM3U')) {
                return this.parseM3U(content);
            } else if (url.endsWith('.pls') || content.includes('[playlist]')) {
                return this.parsePLS(content);
            } else if (url.endsWith('.xspf') || content.includes('<playlist')) {
                return this.parseXSPF(content);
            } else {
                throw new Error('Unsupported playlist format');
            }
        } catch (error) {
            console.error('Error parsing playlist:', error);
            throw error;
        }
    }

    // Parse M3U/M3U8 playlist
    static parseM3U(content) {
        const lines = content.split('\n');
        const stations = [];
        let currentStation = {};

        lines.forEach(line => {
            line = line.trim();
            if (!line) return;
            
            if (line.startsWith('#EXTINF:')) {
                // Parse the EXTINF line which contains metadata
                const metaData = line.substring(8).split(',', 2);
                currentStation = { 
                    duration: parseFloat(metaData[0]), 
                    name: metaData[1] || 'Unknown Station'
                };
                
                // Extract additional metadata from the EXTINF line if available
                const extInfoMatch = line.match(/#EXTINF:.*tvg-logo="([^"]*)".*group-title="([^"]*)"/);
                if (extInfoMatch) {
                    currentStation.logo = extInfoMatch[1];
                    currentStation.category = extInfoMatch[2];
                }
            } else if (line.startsWith('#EXTGRP:')) {
                // Group/category information
                currentStation.category = line.substring(8).trim();
            } else if (line.startsWith('#EXTIMG:')) {
                // Image/logo information
                currentStation.logo = line.substring(8).trim();
            } else if (!line.startsWith('#') && line.includes('://')) {
                // This is a URL
                currentStation.url = line;
                stations.push({ ...currentStation });
                currentStation = {};
            }
        });

        return stations;
    }

    // Parse PLS playlist
    static parsePLS(content) {
        const lines = content.split('\n');
        const stations = [];
        const entries = {};
        
        // First pass: gather all information
        lines.forEach(line => {
            line = line.trim();
            if (!line || line === '[playlist]') return;
            
            const keyValue = line.split('=', 2);
            if (keyValue.length !== 2) return;
            
            const [key, value] = keyValue;
            
            // Parse key to get entry number and property
            const keyMatch = key.match(/^(File|Title|Length)(\d+)$/i);
            if (!keyMatch) return;
            
            const [_, property, numberStr] = keyMatch;
            const number = parseInt(numberStr);
            
            if (!entries[number]) {
                entries[number] = {};
            }
            
            if (property.toLowerCase() === 'file') {
                entries[number].url = value;
            } else if (property.toLowerCase() === 'title') {
                entries[number].name = value;
            } else if (property.toLowerCase() === 'length') {
                entries[number].duration = parseInt(value);
            }
        });
        
        // Second pass: create station objects
        Object.values(entries).forEach(entry => {
            if (entry.url) {
                stations.push({
                    name: entry.name || 'Unknown Station',
                    url: entry.url,
                    duration: entry.duration || -1
                });
            }
        });
        
        return stations;
    }

    // Parse XSPF (XML Shareable Playlist Format)
    static parseXSPF(content) {
        const parser = new DOMParser();
        const xmlDoc = parser.parseFromString(content, 'text/xml');
        const tracks = xmlDoc.getElementsByTagName('track');
        const stations = [];
        
        for (let i = 0; i < tracks.length; i++) {
            const track = tracks[i];
            const location = track.getElementsByTagName('location')[0]?.textContent;
            
            if (location) {
                const title = track.getElementsByTagName('title')[0]?.textContent || 'Unknown Station';
                const image = track.getElementsByTagName('image')[0]?.textContent;
                const album = track.getElementsByTagName('album')[0]?.textContent;
                const duration = track.getElementsByTagName('duration')[0]?.textContent;
                
                stations.push({
                    name: title,
                    url: location,
                    logo: image,
                    album: album,
                    duration: duration ? parseInt(duration) : -1
                });
            }
        }
        
        return stations;
    }
}

// Example usage:
// Function to implement the enhanced audio player
function setupEnhancedPlayer() {
    const audioElement = document.getElementById('audio-player');
    const stationList = document.getElementById('station-list');
    const playPauseButton = document.getElementById('play-pause');
    const volumeControl = document.getElementById('volume');
    const nowPlaying = document.getElementById('now-playing');
    const trackInfo = document.getElementById('track-info');
    const toggleFavoriteButton = document.getElementById('toggle-favorite');
    const favoritesList = document.getElementById('favorites-list');
    const equalizer = document.getElementById('equalizer');
    const bars = equalizer.querySelectorAll('.bar');
    const searchInput = document.getElementById('search-input');
    const categoryButtons = document.querySelectorAll('.category-filter button');
    const recentlyPlayedList = document.getElementById('recently-played-list');
    const favoritesEmptyState = document.getElementById('favorites-empty-state');
    
    let favorites = JSON.parse(localStorage.getItem('favorites')) || [];
    let recentlyPlayed = JSON.parse(localStorage.getItem('recentlyPlayed')) || [];
    let allStations = [];
    let filteredStations = [];
    let animationFrame;
    
    // Create the enhanced audio player
    const player = new EnhancedAudioPlayer({
        audioElement: audioElement,
        fallbackFormats: ['mp3', 'aac', 'ogg', 'opus', 'flac'],
        maxRetries: 3,
    });
    
    // Load radio stations from multiple sources
    async function loadStations() {
        try {
            // Show loading indicator
            stationList.innerHTML = '<li class="loading">Loading stations...</li>';
            
            // Load stations from multiple sources for diversity
            const sources = [
                'https://raw.githubusercontent.com/junguler/m3u-radio-music-playlists/refs/heads/main/%2Bchecked%2B/r/romania.m3u',
                'https://raw.githubusercontent.com/junguler/m3u-radio-music-playlists/refs/heads/main/%2Bchecked%2B/p/pop.m3u',
                'https://raw.githubusercontent.com/junguler/m3u-radio-music-playlists/refs/heads/main/%2Bchecked%2B/r/rock.m3u',
                'https://raw.githubusercontent.com/junguler/m3u-radio-music-playlists/refs/heads/main/%2Bchecked%2B/j/jazz.m3u',
                'https://raw.githubusercontent.com/junguler/m3u-radio-music-playlists/refs/heads/main/%2Bchecked%2B/c/classical.m3u'
            ];
            
            // Create an array of promises for fetching each source
            const fetchPromises = sources.map(async (source, index) => {
                try {
                    const response = await fetch(source);
                    const content = await response.text();
                    
                    // Parse the playlist and add category information
                    const stations = EnhancedAudioPlayer.parseM3U(content);
                    
                    // Assign categories based on source URL
                    const categoryMap = {
                        0: 'Romania',
                        1: 'Pop',
                        2: 'Rock',
                        3: 'Jazz',
                        4: 'Classical'
                    };
                    
                    // Add category and generate random colors for station icons
                    return stations.map(station => {
                        const hue = Math.floor(Math.random() * 360);
                        return {
                            ...station,
                            category: station.category || categoryMap[index] || 'Music',
                            color: `hsl(${hue}, 70%, 60%)`
                        };
                    });
                } catch (error) {
                    console.error(`Error loading source ${index}:`, error);
                    return [];
                }
            });
            
            // Wait for all sources to load
            const results = await Promise.all(fetchPromises);
            
            // Combine all stations
            allStations = results.flat();
            
            // Apply initial filtering
            filteredStations = [...allStations];
            
            // Render stations
            renderStations(filteredStations);
            
            // Render favorites after loading stations
            renderFavorites();
            
            // Render recently played stations
            renderRecentlyPlayed();
        } catch (error) {
            console.error('Error loading stations:', error);
            stationList.innerHTML = '<li class="error">Error loading stations. Please try again later.</li>';
        }
    }
    
    // Render the station list
    function renderStations(stations) {
        stationList.innerHTML = '';
        
        if (stations.length === 0) {
            stationList.innerHTML = '<li class="no-results">No stations found matching your criteria</li>';
            return;
        }
        
        stations.forEach(station => {
            const li = document.createElement('li');
            
            // Get the first letter of the station name for the icon
            const firstLetter = station.name.charAt(0).toUpperCase();
            
            li.innerHTML = `
                <div class="station-icon" style="background-color: ${station.color || '#3498DB'}">
                    ${station.logo ? `<img src="${station.logo}" alt="${station.name}">` : `<i class="fas fa-music"></i>`}
                    ${station.category ? `<span class="station-category">${station.category}</span>` : ''}
                </div>
                <span class="station-name">${station.name}</span>
            `;
            li.setAttribute('data-src', station.url);
            li.setAttribute('data-name', station.name);
            li.setAttribute('data-category', station.category || 'Music');
            
            if (station.logo) {
                li.setAttribute('data-logo', station.logo);
            }
            
            stationList.appendChild(li);
        });
    }
    
    // Filter stations based on search input and category
    function filterStations() {
        const searchTerm = searchInput.value.toLowerCase();
        const activeCategory = document.querySelector('.category-filter button.active').getAttribute('data-category');
        
        filteredStations = allStations.filter(station => {
            const nameMatch = station.name.toLowerCase().includes(searchTerm);
            const categoryMatch = activeCategory === 'all' || station.category === activeCategory;
            return nameMatch && categoryMatch;
        });
        
        renderStations(filteredStations);
    }
    
    // Render favorites list
    function renderFavorites() {
        favoritesList.innerHTML = '';
        
        if (favorites.length === 0) {
            favoritesEmptyState.style.display = 'block';
            return;
        }
        
        favoritesEmptyState.style.display = 'none';
        
        favorites.forEach(favUrl => {
            const station = allStations.find(s => s.url === favUrl);
            
            if (station) {
                const li = document.createElement('li');
                li.innerHTML = `
                    <div class="station-icon" style="background-color: ${station.color || '#3498DB'}">
                        ${station.logo ? `<img src="${station.logo}" alt="${station.name}">` : `<i class="fas fa-music"></i>`}
                        <span class="station-category">${station.category || 'Music'}</span>
                    </div>
                    <span class="station-name">${station.name}</span>
                    <span class="remove-favorite"><i class="fas fa-times-circle"></i></span>
                `;
                li.setAttribute('data-src', station.url);
                li.setAttribute('data-name', station.name);
                
                favoritesList.appendChild(li);
            }
        });
    }
    
    // Render recently played stations
    function renderRecentlyPlayed() {
        recentlyPlayedList.innerHTML = '';
        
        if (recentlyPlayed.length === 0) {
            recentlyPlayedList.innerHTML = '<li>No recently played stations yet</li>';
            return;
        }
        
        // Show only the last 5 recently played stations
        recentlyPlayed.slice(0, 5).forEach(stationUrl => {
            const station = allStations.find(s => s.url === stationUrl);
            
            if (station) {
                const li = document.createElement('li');
                li.textContent = station.name;
                li.setAttribute('data-src', station.url);
                recentlyPlayedList.appendChild(li);
            }
        });
    }
    
    // Update recently played list
    function updateRecentlyPlayed(stationUrl) {
        // Remove the station if it already exists in the list
        recentlyPlayed = recentlyPlayed.filter(url => url !== stationUrl);
        
        // Add the station to the beginning of the list
        recentlyPlayed.unshift(stationUrl);
        
        // Keep only the last 10 stations
        if (recentlyPlayed.length > 10) {
            recentlyPlayed = recentlyPlayed.slice(0, 10);
        }
        
        // Save to localStorage
        localStorage.setItem('recentlyPlayed', JSON.stringify(recentlyPlayed));
        
        // Update the UI
        renderRecentlyPlayed();
    }
    
    // Toggle favorite status
    function toggleFavorite() {
        const currentStation = player.currentStation;
        
        if (currentStation) {
            const stationUrl = currentStation.getAttribute('data-src');
            
            if (favorites.includes(stationUrl)) {
                favorites = favorites.filter(url => url !== stationUrl);
            } else {
                favorites.push(stationUrl);
            }
            
            localStorage.setItem('favorites', JSON.stringify(favorites));
            updateFavoriteButton();
            renderFavorites();
        }
    }
    
    // Update favorite button UI
    function updateFavoriteButton() {
        const currentStation = player.currentStation;
        
        if (currentStation) {
            const stationUrl = currentStation.getAttribute('data-src');
            const isFavorite = favorites.includes(stationUrl);
            const favoriteIcon = toggleFavoriteButton.querySelector('i');
            
            if (isFavorite) {
                favoriteIcon.classList.remove('far');
                favoriteIcon.classList.add('fas');
            } else {
                favoriteIcon.classList.remove('fas');
                favoriteIcon.classList.add('far');
            }
        }
    }
    
// Animate equalizer bars
function animateEqualizer(isPlaying) {
    if (animationFrame) {
        cancelAnimationFrame(animationFrame);
        animationFrame = null;
    }
    
    if (!isPlaying) {
        // Reset bars to default state when not playing
        bars.forEach(bar => {
            bar.style.height = '5px';
        });
        return;
    }
    
    function animate() {
        bars.forEach(bar => {
            const height = Math.floor(Math.random() * 30) + 5;
            bar.style.height = `${height}px`;
        });
        
        animationFrame = requestAnimationFrame(animate);
    }
    
    animate();
}

// Function to check stream type and handle accordingly
function detectStreamType(url) {
    // Default to mp3 type
    let type = 'audio/mpeg';
    
    // Check URL extension
    if (url.endsWith('.m3u8')) {
        type = 'application/vnd.apple.mpegurl';
    } else if (url.endsWith('.ogg')) {
        type = 'application/ogg';
    } else if (url.endsWith('.aac')) {
        type = 'audio/aac';
    } else if (url.endsWith('.flac')) {
        type = 'audio/flac';
    } else if (url.endsWith('.opus')) {
        type = 'audio/opus';
    } else if (url.endsWith('.wav')) {
        type = 'audio/wav';
    } else if (url.endsWith('.m3u')) {
        return { type: 'm3u-playlist', url };
    } else if (url.endsWith('.pls')) {
        return { type: 'pls-playlist', url };
    }
    
    return { type, url };
}

// Function to fetch and parse playlist files
async function fetchPlaylist(url, playlistType) {
    try {
        const response = await fetch(url);
        const text = await response.text();
        
        if (playlistType === 'm3u-playlist') {
            return parseM3UPlaylist(text);
        } else if (playlistType === 'pls-playlist') {
            return parsePLSPlaylist(text);
        }
        
        return null;
    } catch (error) {
        console.error('Error fetching playlist:', error);
        return null;
    }
}

// Parse M3U playlist
function parseM3UPlaylist(content) {
    const lines = content.split('\n');
    for (let i = 0; i < lines.length; i++) {
        const line = lines[i].trim();
        if (line && !line.startsWith('#') && line.startsWith('http')) {
            return line; // Return the first valid stream URL
        }
    }
    return null;
}

// Parse PLS playlist
function parsePLSPlaylist(content) {
    const lines = content.split('\n');
    for (let i = 0; i < lines.length; i++) {
        const line = lines[i].trim();
        if (line.startsWith('File1=')) {
            return line.substring(6); // Return the first file URL
        }
    }
    return null;
}

// Updated loadStation function to handle different stream types
async function loadStation(stationElement) {
    if (isLoading) return;
    isLoading = true;
    
    // Reset previous station's active state if any
    document.querySelectorAll('#station-list li.playing, #favorites-list li.playing').forEach(el => {
        el.classList.remove('playing');
    });
    
    currentStation = stationElement;
    const stationUrl = stationElement.getAttribute('data-src');
    const stationName = stationElement.querySelector('.station-name').textContent;
    
    nowPlaying.textContent = `Loading: ${stationName}`;
    stationElement.classList.add('playing');
    updateFavoriteButton();
    
    try {
        // Detect stream type
        const streamInfo = detectStreamType(stationUrl);
        let finalUrl = streamInfo.url;
        
        // Handle playlist types
        if (streamInfo.type === 'm3u-playlist' || streamInfo.type === 'pls-playlist') {
            const streamUrl = await fetchPlaylist(streamInfo.url, streamInfo.type);
            if (streamUrl) {
                finalUrl = streamUrl;
                // Re-detect the actual stream type from the playlist
                const actualStreamInfo = detectStreamType(finalUrl);
                setAudioSource(finalUrl, actualStreamInfo.type);
            } else {
                throw new Error('Unable to extract stream URL from playlist');
            }
        } else {
            // Direct stream URL
            setAudioSource(finalUrl, streamInfo.type);
        }
        
        // Set up HLS player if needed
        if (streamInfo.type === 'application/vnd.apple.mpegurl') {
            setupHLSPlayer(finalUrl);
        }
        
        // Start or resume playback
        await startPlayback(stationName);
        
    } catch (error) {
        console.error('Playback error:', error);
        nowPlaying.textContent = `Error: Unable to play ${stationName}. ${error.message}`;
        stationElement.classList.add('unavailable');
        stationElement.classList.remove('playing');
        animateEqualizer(false);
    }
    
    isLoading = false;
    updateRecentlyPlayed(stationElement);
}

// Set audio source and type
function setAudioSource(url, type) {
    audioPlayer.innerHTML = ''; // Clear existing sources
    const sourceElement = document.createElement('source');
    sourceElement.src = url;
    sourceElement.type = type;
    audioPlayer.appendChild(sourceElement);
    audioPlayer.load();
}

// Start or resume playback
async function startPlayback(stationName) {
    try {
        await audioPlayer.play();
        nowPlaying.textContent = `Now playing: ${stationName}`;
        playPauseButton.innerHTML = '<i class="fas fa-pause"></i> Pause';
        animateEqualizer(true);
        
        // Set up metadata observer if available
        setupMetadataObserver();
    } catch (error) {
        throw new Error(`Playback failed: ${error.message}`);
    }
}

// Set up HLS player for HLS streams if browser doesn't support it natively
function setupHLSPlayer(url) {
    // Check if HLS.js is available and HLS is not natively supported
    if (typeof Hls !== 'undefined' && !audioPlayer.canPlayType('application/vnd.apple.mpegurl')) {
        const hls = new Hls();
        hls.loadSource(url);
        hls.attachMedia(audioPlayer);
        
        hls.on(Hls.Events.ERROR, function(event, data) {
            if (data.fatal) {
                console.error('HLS.js fatal error:', data);
                nowPlaying.textContent = 'Error: HLS stream playback failed.';
            }
        });
    }
}

// Monitor metadata updates if the stream provides them
function setupMetadataObserver() {
    if ('mediaSession' in navigator) {
        audioPlayer.addEventListener('playing', updateMediaSessionMetadata);
    }
    
    // Some Icecast/Shoutcast streams expose metadata via audio.mozGetMetadata or custom events
    if (audioPlayer.mozGetMetadata && typeof audioPlayer.mozGetMetadata === 'function') {
        setInterval(() => {
            const metadata = audioPlayer.mozGetMetadata();
            if (metadata && metadata.title) {
                updateTrackInfo(metadata.title);
            }
        }, 5000);
    }
}

// Update track info display
function updateTrackInfo(title) {
    if (title) {
        trackInfo.textContent = title;
        
        // Also update Media Session metadata if available
        if ('mediaSession' in navigator) {
            navigator.mediaSession.metadata = new MediaMetadata({
                title: title,
                artist: currentStation ? currentStation.querySelector('.station-name').textContent : 'Unknown Station',
                artwork: [
                    { src: 'radio-icon.png', sizes: '512x512', type: 'image/png' }
                ]
            });
        }
    } else {
        trackInfo.textContent = '';
    }
}

// Update Media Session metadata
function updateMediaSessionMetadata() {
    if ('mediaSession' in navigator) {
        navigator.mediaSession.metadata = new MediaMetadata({
            title: 'Live Stream',
            artist: currentStation ? currentStation.querySelector('.station-name').textContent : 'Unknown Station',
            artwork: [
                { src: 'radio-icon.png', sizes: '512x512', type: 'image/png' }
            ]
        });
        
        // Set up media session action handlers
        navigator.mediaSession.setActionHandler('play', () => {
            audioPlayer.play();
            playPauseButton.innerHTML = '<i class="fas fa-pause"></i> Pause';
            animateEqualizer(true);
        });
        
        navigator.mediaSession.setActionHandler('pause', () => {
            audioPlayer.pause();
            playPauseButton.innerHTML = '<i class="fas fa-play"></i> Play';
            animateEqualizer(false);
        });
    }
}

// Load multiple station sources
async function loadMultipleSources() {
    try {
        // Array of playlist sources
        const sources = [
            {
                url: 'https://raw.githubusercontent.com/junguler/m3u-radio-music-playlists/main/+checked+/r/romania.m3u',
                name: 'Romania',
                category: 'Music'
            },
            {
                url: 'https://raw.githubusercontent.com/junguler/m3u-radio-music-playlists/main/+checked+/j/jazz.m3u',
                name: 'Jazz',
                category: 'Music'
            },
            {
                url: 'https://raw.githubusercontent.com/junguler/m3u-radio-music-playlists/main/+checked+/n/news.m3u',
                name: 'News',
                category: 'News'
            },
            {
                url: 'https://raw.githubusercontent.com/junguler/m3u-radio-music-playlists/main/+checked+/t/talk.m3u',
                name: 'Talk Shows',
                category: 'Talk'
            }
        ];
        
        for (const source of sources) {
            try {
                const response = await fetch(source.url);
                const m3uText = await response.text();
                const stations = parseM3U(m3uText, source.category);
                
                // Add all stations to the list
                stations.forEach(station => {
                    const li = document.createElement('li');
                    const iconColor = getRandomColor();
                    
                    li.innerHTML = `
                        <div class="station-icon" style="background-color: ${iconColor}">
                            <i class="${getCategoryIcon(station.category)}"></i>
                            <span class="station-category">${station.category}</span>
                        </div>
                        <span class="station-name">${station.name}</span>
                    `;
                    li.setAttribute('data-src', station.url);
                    li.setAttribute('data-category', station.category);
                    stationList.appendChild(li);
                });
            } catch (error) {
                console.error(`Error loading stations from ${source.url}:`, error);
            }
        }
        
        // After loading all stations, filter by active category
        filterStationsByCategory(document.querySelector('.category-filter button.active').getAttribute('data-category'));
        
    } catch (error) {
        console.error('Error loading stations:', error);
    }
}

// Enhanced M3U parser with category support
function parseM3U(m3uText, defaultCategory = 'Music') {
    const lines = m3uText.split('\n');
    const stations = [];
    let currentStation = { category: defaultCategory };

    lines.forEach(line => {
        line = line.trim();
        if (line.startsWith('#EXTINF:')) {
            // Extract name from standard M3U format
            let name = line.split(',')[1];
            if (!name) {
                // Try alternative format
                const match = line.match(/#EXTINF:-1,(.+)/);
                if (match && match[1]) {
                    name = match[1];
                }
            }
            currentStation.name = name || 'Unknown Station';
            
            // Check if there's category information
            if (line.includes('group-title=')) {
                const match = line.match(/group-title="([^"]+)"/);
                if (match && match[1]) {
                    currentStation.category = match[1];
                }
            }
        } else if (line.startsWith('http')) {
            currentStation.url = line;
            if (currentStation.name) {
                stations.push({ ...currentStation });
            }
            currentStation = { category: defaultCategory };
        }
    });

    return stations;
}

// Get appropriate icon for station category
function getCategoryIcon(category) {
    const categoryIcons = {
        'Music': 'fas fa-music',
        'News': 'fas fa-newspaper',
        'Talk': 'fas fa-microphone',
        'Fitness': 'fas fa-dumbbell',
        'Spiritual': 'fas fa-pray',
        'Sport': 'fas fa-futbol',
        'Comedy': 'fas fa-laugh',
        'Culture': 'fas fa-theater-masks',
        'Classic': 'fas fa-violin'
    };
    
    return categoryIcons[category] || 'fas fa-broadcast-tower';
}

// Generate random color for station icons
function getRandomColor() {
    const colors = [
        '#3498DB', // Blue
        '#E74C3C', // Red
        '#2ECC71', // Green
        '#F39C12', // Orange
        '#9B59B6', // Purple
        '#1ABC9C', // Turquoise
        '#D35400', // Pumpkin
        '#34495E'  // Dark Blue
    ];
    
    return colors[Math.floor(Math.random() * colors.length)];
}

// Filter stations by category
function filterStationsByCategory(category) {
    const stations = document.querySelectorAll('#station-list li');
    
    stations.forEach(station => {
        if (category === 'all' || station.getAttribute('data-category') === category) {
            station.style.display = 'flex';
        } else {
            station.style.display = 'none';
        }
    });
}

// Update recently played stations
function updateRecentlyPlayed(stationElement) {
    const stationName = stationElement.querySelector('.station-name').textContent;
    const stationUrl = stationElement.getAttribute('data-src');
    const recentlyPlayedList = document.getElementById('recently-played-list');
    
    // Check if this station is already in the list
    const existingStation = Array.from(recentlyPlayedList.children).find(li => 
        li.getAttribute('data-src') === stationUrl
    );
    
    if (existingStation) {
        // Move to top if already in list
        recentlyPlayedList.insertBefore(existingStation, recentlyPlayedList.firstChild);
    } else {
        // Add new entry at the top
        const li = document.createElement('li');
        li.textContent = stationName;
        li.setAttribute('data-src', stationUrl);
        
        // Insert at the beginning
        if (recentlyPlayedList.firstChild) {
            recentlyPlayedList.insertBefore(li, recentlyPlayedList.firstChild);
        } else {
            recentlyPlayedList.appendChild(li);
        }
        
        // Limit to 10 items
        if (recentlyPlayedList.children.length > 10) {
            recentlyPlayedList.removeChild(recentlyPlayedList.lastChild);
        }
    }
    
    // Save to localStorage
    saveRecentlyPlayed();
}

// Save recently played stations to localStorage
function saveRecentlyPlayed() {
    const recentlyPlayedList = document.getElementById('recently-played-list');
    const recentlyPlayed = Array.from(recentlyPlayedList.children).map(li => {
        return {
            name: li.textContent,
            url: li.getAttribute('data-src')
        };
    });
    
    localStorage.setItem('recentlyPlayed', JSON.stringify(recentlyPlayed));
}

// Load recently played stations from localStorage
function loadRecentlyPlayed() {
    const recentlyPlayedList = document.getElementById('recently-played-list');
    const recentlyPlayed = JSON.parse(localStorage.getItem('recentlyPlayed')) || [];
    
    recentlyPlayedList.innerHTML = '';
    recentlyPlayed.forEach(station => {
        const li = document.createElement('li');
        li.textContent = station.name;
        li.setAttribute('data-src', station.url);
        recentlyPlayedList.appendChild(li);
    });
}

// Event listeners

// Category filter buttons
document.querySelectorAll('.category-filter button').forEach(button => {
    button.addEventListener('click', function() {
        // Remove active class from all buttons
        document.querySelectorAll('.category-filter button').forEach(btn => {
            btn.classList.remove('active');
        });
        
        // Add active class to clicked button
        this.classList.add('active');
        
        // Filter stations
        filterStationsByCategory(this.getAttribute('data-category'));
    });
});

// Recently played list click handler
document.getElementById('recently-played-list').addEventListener('click', (e) => {
    if (e.target.tagName === 'LI') {
        const stationUrl = e.target.getAttribute('data-src');
        
        // Find the actual station element
        const stationElement = Array.from(stationList.querySelectorAll('li')).find(
            li => li.getAttribute('data-src') === stationUrl
        );
        
        if (stationElement) {
            loadStation(stationElement);
        }
    }
});

// Theme switcher
document.getElementById('theme-select').addEventListener('change', function() {
    document.body.setAttribute('data-theme', this.value);
    localStorage.setItem('theme', this.value);
});

// Search functionality
document.getElementById('search-input').addEventListener('input', function() {
    const searchTerm = this.value.toLowerCase();
    const stations = document.querySelectorAll('#station-list li');
    
    stations.forEach(station => {
        const stationName = station.querySelector('.station-name').textContent.toLowerCase();
        
        if (stationName.includes(searchTerm)) {
            station.style.display = 'flex';
        } else {
            station.style.display = 'none';
        }
    });
});

// Media keys support
if ('mediaSession' in navigator) {
    navigator.mediaSession.setActionHandler('play', () => {
        audioPlayer.play();
        playPauseButton.innerHTML = '<i class="fas fa-pause"></i> Pause';
        animateEqualizer(true);
    });
    
    navigator.mediaSession.setActionHandler('pause', () => {
        audioPlayer.pause();
        playPauseButton.innerHTML = '<i class="fas fa-play"></i> Play';
        animateEqualizer(false);
    });
}

// Audio player error handler
audioPlayer.addEventListener('error', (e) => {
    console.error('Audio player error:', e);
    nowPlaying.textContent = `Error: Unable to play stream. (Code: ${audioPlayer.error.code})`;
    playPauseButton.innerHTML = '<i class="fas fa-play"></i> Play';
    animateEqualizer(false);
    
    if (currentStation) {
        currentStation.classList.remove('playing');
    }
});

// Get equalizer bars
const bars = document.querySelectorAll('.bar');
let animationFrame = null;

// Initialize the application
document.addEventListener('DOMContentLoaded', () => {
    // Load saved theme
    const savedTheme = localStorage.getItem('theme');
    if (savedTheme) {
        document.body.setAttribute('data-theme', savedTheme);
        document.getElementById('theme-select').value = savedTheme;
    }
    
    loadMultipleSources();
    loadFavorites();
    loadRecentlyPlayed();
});
</script>
</body>
</html>
